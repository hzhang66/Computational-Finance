#MFE405 Computational Methods in Finance
#Project 1: Applying LGM to generate random variables
#Author: Heyu Zhang
import numpy as np
import math
import matplotlib.pyplot as plt
import time
import random

#LGM setting
m=2**31-1
a=7**5
b=0
#problem1
#1.
x=713 #set a random seed
list1_LGM=[]     #Uniform Distribution list generated by LGM
for i in range(10000):   #generate 10000 random variables
    x=(a*x+b)%m
    list1_LGM.append(x/m)
print('LGM:','\n',"Empirical mean is ", np.mean(list1_LGM),'\n',"Empirical standard deviation is ",np.std(list1_LGM))
#2.
list1_BUILTIN=[]      #Uniform Distribution list generated by BuiltIn method in Python
for i in range(10000):
    list1_BUILTIN.append(random.uniform(0, 1))
print('\n','BuiltIn:','\n',"Mean is ", np.mean(list1_BUILTIN),'\n',"Standard deviation is ",np.std(list1_BUILTIN))

#problem2
#1.
list2_LGM=[]      #Discrete Distribution list of problem 2
for i in list1_LGM:    #Using the Uniform Distribution list generated by LGM in problem 1
    if i<=0.3:
        x=-1
    elif i<=0.65:
        x=0
    elif i<=0.85:
        x=1
    else:
        x=2
    list2_LGM.append(x)    
#2.
plt.hist(list2_LGM)   #Plot the histogram of Discrete Distribution
plt.title('Histogram of LGM Simulation')
plt.xlabel('X')
plt.ylabel('Frequency')
plt.show()
print("Empirical mean is", np.mean(list2_LGM),'\n',"Empirical standard deviation is",np.std(list2_LGM))

#problem3
#1.
x=71345 #set a random seed
list3_Bernoulli_LGM=[]    #Bernoulli Distribution list generated by LGM
list3_LGM=[]    #Binomial(44,0.64) Distribution list generated by LGM
for i in range(44000):
    x=(a*x+b)%m
    if (x/m)<=0.64:     #Let Prob(y=1)=0.64
        y=1
    else:
        y=0
    list3_Bernoulli_LGM.append(y)
for i in range(1000):
    list3_LGM.append(sum(list3_Bernoulli_LGM[44*i:44*(i+1)]))    #sum of 44 Bernoulli (0.64)
#2.
plt.hist(list3_LGM, bins=20)    #Plot the histogram of Binomial(44,0.64) Distribution
plt.title('Histogram of Binomial(44,0.64) LGM Simulation')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.show()
prob1=sum([1 for i in list3_LGM if i>=40])/len(list3_LGM)    #calculate P(X>=40)
print('P(X>=40)=',prob1,'when X~Binomial(44,0.64)')

#problem4
#1.
list4_LGM=[-1.5*math.log(i) for i in list1_LGM]   #Generate Exponancial distributed random variables by converting every r.v in the Uniform Distribution list generated by LGM in problem 1
#2.
prob2=sum([1 for i in list4_LGM if i>=1])/len(list4_LGM)   #calculate  P(X>=1)
prob3=sum([1 for i in list4_LGM if i>=4])/len(list4_LGM)  #calculate  P(X>=4)
print('P(X>=1)=',prob2,'when X~Exp(1.5)')
print('P(X>=4)=',prob3,'when X~Exp(1.5)')
#3.
plt.hist(list4_LGM, bins=30)   #Plot the histogram of Exp(1.5) Distribution
plt.title('Histogram of Exp(1.5) LGM Simulation')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.show()
print("Empirical mean is", np.mean(list4_LGM),'\n',"Empirical standard deviation is",np.std(list4_LGM))

#problem5
#1. Box-Muller Method
x1=7436783        #set a random seed
x2=54563765     #set a random seed
U1_LGM=[]         #Uniform Distribution U1 generated by LGM
U2_LGM=[]        #Uniform Distribution U2 generated by LGM
Z_BoxMuller=[]        #Normal distribution list gereated by Box-Muller Method
start = time.process_time()     #set start time point to calculate the execution time of Box-Muller Method
for i in range(5000):
    x1=(a*x1+b)%m
    x2=(a*x2+b)%m
    U1_LGM.append(x1/m)
    U2_LGM.append(x2/m)
    z1=math.sqrt(-2*math.log(U1_LGM[i]))*math.cos(2*math.pi*U2_LGM[i])    #calculate r.v1 ~ i.i.d N(0,1) by U1 & U2
    z2=math.sqrt(-2*math.log(U1_LGM[i]))*math.sin(2*math.pi*U2_LGM[i])    #calculate r.v2 ~ i.i.d N(0,1) by U1 & U2
    Z_BoxMuller.append(z1)
    Z_BoxMuller.append(z2)
execu_time_BM=time.process_time()-start    #calculate the execution time of Box-Muller Method
print('Box-Muller Method:','\n',"Empirical mean is", np.mean(Z_BoxMuller),'\n',"Empirical standard deviation is",np.std(Z_BoxMuller))
#2. Polar-Marsaglia Method
U1_LGM=[]
U2_LGM=[]
Z_PolarMarsaglia=[]     #Normal distribution list gereated by Polar-Marsaglia Method
start = time.process_time()        #set start time point to calculate the execution time of Polar-Marsaglia Method
for i in range(2500*2):     #since P(w<1)=4/pi, we should enlarge the number of generated w to make sure we will get 5000 r.v ~ N(0,1)
    if len(Z_PolarMarsaglia)==5000:  #Ensure that we generate 5000 r.v in total
        break
    x1=(a*x1+b)%m
    x2=(a*x2+b)%m
    U1_LGM.append(x1/m)
    U2_LGM.append(x2/m)
    v1=2*U1_LGM[i]-1        #calculate v1
    v2=2*U2_LGM[i]-1      #calculate v2
    w=v1**2+v2**2          #calculate w
    if w<1:        #ensure that z1 and z2 can be calculated
        z1=v1*math.sqrt(-2*math.log(w)/w)       #calculate r.v1 ~ i.i.d N(0,1) by v1, v2 and w
        z2=v2*math.sqrt(-2*math.log(w)/w)      #calculate r.v2 ~ i.i.d N(0,1) by v1, v2 and w
        Z_PolarMarsaglia.append(z1)
        Z_PolarMarsaglia.append(z2)
    else :
        next
execu_time_PM=time.process_time()-start      #calculate the execution time of Polar-Marsaglia Method
print('Polar-Marsaglia Method:','\n',"Empirical mean is", np.mean(Z_PolarMarsaglia),'\n',"Empirical standard deviation is",np.std(Z_PolarMarsaglia))
#3.
print("The execution time of Box-Muller method is",execu_time_BM,'\n',"The execution time of Polar-Marsaglia method is",execu_time_PM)
